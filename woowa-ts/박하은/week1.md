## 1장

- JS에 어떤 기능이 추가된다면 런타임 환경인 브라우저도 이 기능을 지원할 수 있어야함
  - 폴리필(브라우저가 지원하지 않는 코드를 변환해줌), 트랜스파일(최신 버전의 코드를 예전 버전의 코드로 변환) 등장
- 컴포넌트: 모듈과 유사하게 하나의 독립된 기능을 재사용하기 위한 코드 묶음
  - 모듈과는 달리, 런타임 환경에서 독립적으로 배포/실행될 수 있음

### JS의 한계

- 동적타입 언어: 코드가 실행되는 런타임에 변숫값이 할당될때 해당 값의 타입에 따라 변수 타입이 결정됨
  - 이 한계를 극복할 수 있는, JS의 슈퍼셋 언어인 TS가 등장
  - superset 언어: 기존 언어에 새로운 기능과 문법을 추가해 보완한 것

### TS

- 정적 타이핑: 컴파일 단계에서 타입 검사를 해 런타임 에러를 사전에 방지할 수 있음

## 2장 : 타입

- 자료형으로서의 타입: 값의 종류를 명시하면 메모리 공간을 차지할 값의 크기를 미리 알고, 효율적으로 사용 가능
- 정적 타입: 모든 변수의 타입이 컴파일 타임(코드가 기계어로 변환되는 시점)에 결정됨
- 동적 타입: 변수 타입이 런타임(변환된 파일이 메모리에 적재되어 실행되는 시점)에 결정됨
- 타입스크립트는 강타입 언어다.
  - 강타입: 암묵적 타입 변환을 하지 않음

### TS의 타입 시스템

- type annotation: 변수나 상수, 파라미터, 리턴 값에 타입을 명시적으로 선언하는 것
- 점진적인 타입 확인: 필요에 따라 타입 선언을 생략 가능
- 값과 타입은 TS에서 별도의 네임스페이스의 존재하나, 클래스와 enum은 값과 타입 공간에 동시에 존재하는 심볼이다.
  - TS의 클래스는 타입 애너테이션으로 사용할 수 있지만, 런타임에서 객체로 변환해 JS의 값으로 사용할 수도 있음
  - TS 문법인 enum도 런타임에 실제 객체로 존재하며 함수로 표현 가능

#### 구조적 타이핑 

- 구조적 타이핑: 타입은 이름으로가 아니라 구조로 타입을 구분한다.
  - 타입스크립트의 타입은 "값의 집합"이다.
- 구조적 섭타이핑: 객체가 가진 프로퍼티로 타입을 구분한다.
  - 자바의 인터페이스 등에서는 **이름이 무조건 같아야 동일한 타입**인데, TS에서는 프로퍼티(구성 성분)이 같으면 같은 타입으로 인정됨  
  - 두 타입간의 호환성이 타입 내부 구조에 의해서만 결정된다.
- **덕 타이핑**: 명시적인 이름으로 타입을 구분하는 대신 객체나 함수가 가진 구조적 특성을 기반으로 타이핑

### enum


- enum은 트리쉐이킹이 되지 않아 번들 사이즈에 영향을 줄 수 있지만 const enum으로 해결할 수 있다.(p.61)
  - 빌드 과정에서 참조값만 남긴다.
- enum의 리버스 매핑은 컴파일러에서 처리하면 안 되는 동작이라는 의견도 있음
- enum은 JS로 컴파일될때 IIFE로 바뀌어 성능에 영향을 줄 수도 있음


### TS에서 타입을 확인하는 방법

: **typeof, instanceof, 타입 단언(as), 타입 가드**

- instanceof 연산자 사용하면 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단 가능. 
typeof 연산자처럼 instanceof 연산자의 필터링으로 타입이 보장된 상태에서 안전하게 값의 타입을 정제해 사용 가능
- 그러나, TS의 타입 시스템과 문법은 컴파일 단계에서 제거되므로 타입 단언이 런타임에서는 효력을 발휘하지 못함 (p.65)
- 타입 가드: 특정 조건을 검사해서 타입을 정제하고, 타입 안정성을 높이는 패턴

### TS의 array 타입 (p.73)

- 타입스크립트에서는 배열을 array라는 별도 타입으로 다룸.
  - 원소의 타입을 하나로 강제함

## 문제 

1. TS가 덕타이핑 기반이라는 것은 무슨 뜻인가요?
2. TS의 number 타입은 무슨 데이터를 포함하나요?
3. TS에서 object 타입을 권장하지 않는 이유는?

#### 정답

1. 타입을 이름으로 구분하는 게 아니라, 타입의 프로퍼티를 기준으로 결정함
2. 정수, 소수, NaN, Infinity 등
3. any타입과 유사하게 객체에 해당하는 모든 값을 할당할 수 있어 너무 광범위하기 때문에 